<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Oliver Peoples: C-Geometry</title>

  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="prism/prism.css" />
</head>

<div class="split left">
  <h2>
    Navigation
  </h2>
  <h4>
    <a href="index.html">Home</a>
    <br>
    Hamiltonian Mathematics Library
    <br>
    <a href="c-geometry.html">C-Geometry</a>
    <br>
    Algorithmic Art
  </h4>
</div>

<body id="top"></body>
  <div class="split right">
  <main>
    <div class="centered">
      <header>
        <h1>
          Mathematics $\cap$ Geospatial Science $\cap$ Computer Science
          <br>
          <br>
          <i>C-Geometry</i>
        </h1>
      </header>
      <div class="abstract">
        <h2>
          Abstract
        </h2>
        <p>
          The Hamiltonian Mathematics Library, hmath, provides a light weight implementation of a number of different algebras, however it comes as is with only <i>the definition</i> of those algebras, with few tools for using them to do the extent of the work they are capable of. Presented is the C-Geometry library, based upon the capabilities of the Hamiltonian Mathematics Library, for manipulating points, groups of points, meshes, generating polyhedra, etc. The library, written in C++, takes advantage of the language's pointer capabilities to allow for semi-optimized operations, as well as set like operations on points, making it a capable library both computationally and mathematically.
        </p>
      </div>
      <div>
        <h2>
          Core Elements
        </h2>
        <h3>
          Underlying Algebra
        </h3>
        <p>
          $\mathbb{R}^{3}$ is commonly thought of as a vector, however, it is ultimately just a group of ordered triplets of real numbers. For the vast majority of operations which this library is targeted at, three-dimensional Euclidean space, $\mathbb{E}^{3}$, is the space of interest. Hence, the foundation class of the library, for Euclidean operations at least, is $\texttt{PointE3}$. This class has at its heart, five potential representations, part of the namesapce $\texttt{Euclidean}$:
        </p>
        <ol>
          <li>$\texttt{PhysicsSpherical}$- Spherical coordinates in classical physics style notation and variable allocation: $\{ \rho,\theta,\phi \}$</li>
          <li>$\texttt{MathSpherical}$ - Spherical coordinates in classical mathematics style notation and variable allocation: $\{ \rho,\theta,\phi \}$</li>
          <li>$\texttt{CartoSpherical}$ - Spherical coordiantes in a cartographic style notation and variable allocation, with $\rho$ instead of altitude: $\{ \rho,\theta,\alpha \}$</li>
          <li>$\texttt{Cylindrical}$ - Cylindrical coordinates: $\{ \rho,\theta,z \}$</li>
          <li>$\texttt{Cartesian}$ - Cartesian coordinates, $\{ x,y,z \}$</li>
        </ol>
        <p>
          A $\texttt{union}$ type is used privately within a $\texttt{PointE3}$ object such that only one of these representations of a point is kept at a single time, with each representation accessible via method call, conducting the conversion as the method is called iff the called $\mathbb{E}^{3}$ representation is not the same as the one currently held by the union. This implies an awareness on the part of the $\texttt{PointE3}$ object of its current $\mathbb{E}^{3}$ representation, which is stored as a private variable that is updated each time the current active union member is changed.
          <br>
          <br>
          While this technique is semantic, it saves memory, at the expense of some processing speed, however this reduction in processing speed can be alleviated by keeping consistent the chosen $\mathbb{E}^{3}$ representation across programs. This choice of memory conservation over processing speed is entirely deliberate; the intent of this library is processing large volumes of geometric data, hence, the reduction of the amount of memory consumed by each point is a primary focus.
          <br>
          <br>
          Consider the case that different coordinate space representations for a single point were kept simultaneously, and that an arbitrary point $p$ existed in mathematic spherical coordinate space. Suppose $p_{\rho}$ is doubled, outdating the four remaining coordinate spaces kept by the object. Further suppose that now the point must be called via its cartesian representation, perhaps for rotation via quaternion. Even though all coordiante spaces are kept simultaneously, for any one to now be called requires a conversion still! The only situation in which storing all coordinate spaces at once is advantageous over single coordinate space storage is when the coordinate space conversion is called without a value manipulation between the current conversion and the last coordiante space conversion.
        </p>
        <h3>
          Unstructured Point Sets
        </h3>
      </div>
    </div>
  </main>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'],],
      },
    }
    const toggle = document.getElementById('typeface-toggle')
    const typeface = document.getElementById('typeface')
    toggle.addEventListener('click', () => {
      document.body.classList.toggle('libertinus')
      typeface.textContent = document.body.classList.contains('libertinus') ? 'Libertinus' : 'Latin Modern'
    })
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script async src="prism/prism.js"></script>

  <script async defer data-domain="latex.now.sh" src="https://plausible.io/js/plausible.js"></script>
</body>

</html>
